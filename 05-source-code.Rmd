# Source Code {#code}

An important principle in any project is how to manage the source code. In this chapter, youâ€™ll learn about the directories that hold the `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")` package source code and some general tips for organizing source code functionality. We'll also add some new functionality to our package to demonstrate our thoughts.

## Organization

Organizing your source code provides many benefits such as:

- making the intentions of the code obvious,
- making it easy for others to contribute,
- making it easy for you to maintain,
- making it easy to debug,
- making it easy to expand.

```{block, type="note"}
There are very few strict requirements in how you organize your code but what follows are general best practices.
```

### Individual units

> _"Functions should do one thing. They should do it well. They should do it only."_ - Robert Martin

Individual units of functionality (i.e. functions, methods, classes) should be <font size="-2">small.</font> How small? That's the magic question `r emo::ji("shrug")`. Individual units of functionality should not require significant scrolling in your editor. They should be very clear regarding the intention and functionality they are providing. And they should only _"do one thing"_.

```{block, type="tip"}
One way to know if a function is doing more than one thing is if you can extract another function from it with a name that is not merely a restatement of its implementation.
```

So far our package has only one simple function; however, we typically build our packages to be more comprehensive and complex. Organizing this expansion is important. There are two main ways our code expands:

1. breadth: we add more functionality but not necessarily building onto existing functionality,
2. aggregation: we continue building onto existing functionality to create layers of abstraction.

### Expanding code breadth

Expanding code breadth is easier to maintain. For our example package that currently has a `my_mean()` function, this could include adding new functions such as `my_median()` and  `my_mode()`. When expanding code breadth the main thing you should consider is where to put the new functionality.

Grouping like functionality into one file is good. For example, since `my_mean()`, `my_median()` and `my_mode()` are all forms of central tendencies we may put them in the same file while functions with other purposes (i.e. deviations) may go into a different file.

While you're free to arrange functions into files as you wish, the two extremes are bad: don't put all functions into one file and don't put each function into its own separate file. (It's OK if some files only contain one function, particularly if the function is large `r emo::ji("stop_sign")` or has a lot of documentation.).

### Aggregating functionality

Often, we write code that builds on top of each other. This is known as creating higher levels of abstraction. For example, say we wanted to create a function that computes the z-score, which uses the mean and standard deviations ($z=\frac{x - \mu}{\sigma}$). This is a higher level of abstraction and we should write our code in such a way that:

1. our code reads like a top-down narrative,
2. functionality is abstracted away and grouped at similar levels of abstraction.

If your code still fits into one file, we want the code to read like a top-down narrative where the highest level of abstraction is exposed first followed by the next level of abstraction. This means your highest abstracted function should be at the top of the .R or .py script and then as you scroll down functions lower level functions that provide supporting help should be listed. For example, a simple file that holds functionality to compute the z-score would look like:

```python
# highest abstracted level
def z_score():
  pass
  
# next layer of abstractoin
def my_mean():
  pass
  
def my_sd():
  pass
  
# lowest level of abstraction
def validate_input():
  pass
```

If your code grows signicantly then you want to separate functionality into separate files but still group functions based on similar levels of abstraction.

### Naming is important

Naming is important but as our source code grows it becomes even moreso. Here are some good naming tips:

- If a file contains a single function, give the file the same name as the function.
- If a file contains multiple related functions, give it a concise, but descriptive name. For example, we could group `my_mean()`, `my_median()` and `my_mode()` together into a file named `central_tendencies`.
- Sometimes you have many helper functions in your source code that all support one primary user facing API functionality. Put the user-facing API function/class into a file named `main` or `main_api`.
- Many times people create a general `utils` file to hold general utility functions. This is not advised. Always try to find a proper home and name for all supporting functions. This is a [great read](https://breadcrumbscollector.tech/stop-naming-your-python-modules-utils/) explaining why.
- Deprecated functions should live in a file or directory that makes it obvious they are deprecated (i.e. prefix file name with `deprec-`).


## External vs internal

When developing packages, we often build functions with two main purposes:

1. External use: functions that are designed to be used by the end-user. This is the primary purpose of writing a package, to make some functionality easier for an end-user.
2. Internal use: functions that are designed to help you, the developer, write efficient and effect code. Internal functions are usually not intended for external use by end-users.

With both `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")` you have the ability to make your functions be either externally or internally focused. In the sections that follow we will illustrate how but it is important that you apply the same rules to both external and internal functions - document and test __all__ your functions. Although not a requirement this will make your life and other developer's lives that want to contribute much easier.

## `r fontawesome::fa("r-project")` example

For an `r fontawesome::fa("r-project")` package, all source code goes in the `R/` directory and you cannot have subdirectories^[Subdirectories are actually allowed but they can only be for OS-specific purposes and named `unit/` or `windows/`. See this [Stackoverflow question](https://stackoverflow.com/questions/14902199/using-source-subdirectories-within-r-packages-with-roxygen2) for details.].

Let's add some functionality to our package to illustrate some points from our previous discussion:

- add an internally-focused function that validates the user inputs,
- add breadth to our package by adding additional summary statistics computations,
- add aggregation to our package by adding a z-score computation that leverages other functions within our package.

```{block, type='note'}
To simplify, we'll show the final functions and tests added rather than illustrate every step of the test-driven development process.
```

### Setup

Before we start adding new functionality, let's make sure the current code base is ready. Open up your R project, switch to the develop branch and make sure it is current with your remote repo:

```bash
git checkout develop
git pull
```

Now let's create a new branch to add this chapter's new functionality. Usually you name the branch after the new functionality that you're adding or a Github issue that you are addressing. In our case we can name the branch "ch6" since it's related to this chapter.

```bash
git checkout -b ch6
```

### Internal function

First, we'll add an internally-focused function that validates the user inputs. Since we may continue to expand our package and add more validation procedures, we typically create a validation.R file to hold these functions.

Go ahead and create the test and .R file:

```{r, eval=FALSE}
usethis::use_test("validation")
usethis::use_r("validation")
```

Place the following in the `test-validation.R` test file:

```{r, eval=FALSE}
test_that("inputs are a numeric vector", {
  expect_error(validate_numeric_vector("a"))
  expect_error(validate_numeric_vector(factor(1, 2, 3)))
  expect_error(validate_numeric_vector(list(1, 2, 3)))

  expect_silent(c(1, 2, 3))
  expect_silent(c(TRUE, FALSE))
})
```

and the following in the `validation.R` source code file:

```{r, eval=FALSE}
#' Validate numeric vector input
#'
#' @description
#' Checks that an in put is a vector that contains numeric inputs or
#' logical values that can be coerced to numeric values..
#'
#' @param x A numeric or logical vector.
#'
#' @return
#' Raises exception if input is not a numeric or logical vector; otherwise
#' provides a silent return.
#'
#' @examples
#' x <- 1:10
#' myfirstpkg:::validate_numeric_vector(x)
#'
#' @keywords internal
validate_numeric_vector <- function(x) {
  stopifnot(is.atomic(x) || is.logical(x), is.numeric(x))
}
```

Three important items to note in the above:

1. We used the `@keywords internal` tag instead of `@export` as we did in chapter \@ref(workflow). Only functions that are documented with `@export` are made explicitly visible to the end user. Using `@keywords internal` instead of `@export` signals that this function is for internal use only. Internal functions are still accessible to end users but they must use the triple `:::` syntax - `myfirstpkg:::validate_numeric_vector()`.
2. When including examples for internal functions you need to use the triple `:::` syntax - `myfirstpkg:::validate_numeric_vector()` otherwise you will get an error when you run `devtools::check()`.
3. Even though this is an internal package, we still document it as normal. This isn't required but it helps us and contributing developers understand the purpose of the function.

```{block, type='tip'}
Remember, as we add new code we always want to be running the tests.

1. load new functionality: `devtools::load_all()` or Cmd/Ctrl + Shift + L
2. test new functionality: `devtools::test()` or Cmd/Ctrl + Shift + T
3. document new functionality: `devtools::document()` or Cmd/Ctrl + Shift + D
```

Now before adding any new functionality, let's add this validation function to our existing `my_mean()` function. Your `my_mean()` should look like:

```{r, eval=FALSE}
my_mean <- function(x) {
  validate_numeric_vector(x)
  total <- sum(x)
  units <- length(x)
  return(total / units)
}
```

### Adding breadth

Next, let's add a new summary statistic to our collection. For now, we'll store this summary statistic in the same file but in the future if this file became too large we may look to refactor and split up the centralized organization. Let's rename the original `mean.R` file to `summary-stats.R` and also rename the associated test file to `test-summary-stats.R`.

```{block, type='note'}
It is common to rename files and functions as you begin developing a package since you are feeling out what the best design and organization will be but as your package matures this will happen less frequently.
```

Now we'll add a function that computes the standard deviation. Add the following to the `test-summary-stats.R` file:

```{r, eval=FALSE}
test_that("standard deviation of simple vector computes accurately", {
  x <- 1:3
  expect_equal(my_sd(x), 1)
})
```

and add the following to the `summary-stats.R` file in the `R/` directory:

```{r, eval=FALSE}
#' Standard deviation of a vector
#'
#' @description
#' Computes standard deviation of a vector with numeric or logical values.
#'
#' @param x A numeric or logical vector.
#'
#' @details
#' The denominator n - 1 is used which gives an unbiased estimator of the
#' (co)variance for i.i.d. observations.
#'
#' @return
#' The standard deviation of the values in x returned as a numeric vector of
#' length one.
#'
#' @examples
#' x <- 1:10
#' my_sd(x)
#'
#' @export
my_sd <- function(x) {
  validate_numeric_vector(x)
  squared_diff <- (x - my_mean(x))^2
  total <- sum(squared_diff)
  units <- length(x) - 1
  return(sqrt(total / units))
}
```


### Adding aggregation

Last, we'll add a new summary statistics, the z-score, that leverages the `my_mean` and `my_sd` functions. Since this is adding onto our level of abstraction we'll place this at the top of our `R/summary_stats.R` file.

Add the following to the `test-summary-stats.R` file:

```{r, eval=FALSE}
test_that("z-score of simple vector computes accurately", {
  x <- 1:3
  expected <- c(-1, 0, 1)
  expect_equal(z_score(x), expected)
})
```

and add the following to the `summary-stats.R` file in the `R/` directory:

```{r, eval=FALSE}
#' Z-score of a vector
#'
#' @description
#' Computes z-score of a vector with numeric or logical values.
#'
#' @param x A numeric or logical vector.
#'
#' @return
#' The z-score of each value in x returned as a numeric vector of
#' with equal length as the input x vector.
#'
#' @examples
#' x <- 1:3
#' z_score(x)
#'
#' @export
z_score <- function(x) {
  return((x - my_mean(x)) / my_sd(x))
}
```

Our `summary-stats.R` file should now include three functions in a top-down approach:

```{r, eval=FALSE}
#' Z-score of a vector
#'
#' @description
#' Computes z-score of a vector with numeric or logical values.
#'
#' @param x A numeric or logical vector.
#'
#' @return
#' The z-score of each value in x returned as a numeric vector of
#' with equal length as the input x vector.
#'
#' @examples
#' x <- 1:3
#' z_score(x)
#'
#' @export
z_score <- function(x) {
  return((x - my_mean(x)) / my_sd(x))
}

#' Standard deviation of a vector
#'
#' @description
#' Computes standard deviation of a vector with numeric or logical values.
#'
#' @param x A numeric or logical vector.
#'
#' @details
#' The denominator n - 1 is used which gives an unbiased estimator of the
#' (co)variance for i.i.d. observations.
#'
#' @return
#' The standard deviation of the values in x returned as a numeric vector of
#' length one.
#'
#' @examples
#' x <- 1:10
#' my_sd(x)
#'
#' @export
my_sd <- function(x) {
  validate_numeric_vector(x)
  squared_diff <- (x - my_mean(x))^2
  total <- sum(squared_diff)
  units <- length(x) - 1
  return(sqrt(total / units))
}

#' Mean of a vector
#'
#' @description
#' Computes arithmetic mean of a vector with numeric or logical values.
#'
#' @param x A numeric or logical vector.
#'
#' @return
#' The arithmetic mean of the values in x returned as a numeric vector of length one.
#'
#' @examples
#' x <- 1:10
#' my_mean(x)
#'
#' @export
my_mean <- function(x) {
  validate_numeric_vector(x)
  total <- sum(x)
  units <- length(x)
  return(total / units)
}
```

And our `test-summary-stats.R` file should look like:

```{r, eval=FALSE}
test_that("z-score of simple vector computes accurately", {
  x <- 1:3
  expected <- c(-1, 0, 1)
  expect_equal(z_score(x), expected)
})

test_that("standard deviation of simple vector computes accurately", {
  x <- 1:3
  expect_equal(my_sd(x), 1)
})

test_that("mean of simple vector computes accurately", {
  x <- 0:10
  expect_equal(my_mean(x), 5)
})
```

### Final checks & version control

Now before we commit our changes to git, let's make sure everything is loaded and documented and passes our tests and checks:

1. document package functionality: `devtools::document()` or Cmd/Ctrl + Shift + D
1. load package functionality: `devtools::load_all()` or Cmd/Ctrl + Shift + L
2. test package functionality: `devtools::test()` or Cmd/Ctrl + Shift + T
3. R Cmd check package functionality: `devtools::check()` or Cmd/Ctrl + Shift + E

As long as everything is passing, we can now commit our changes, push to Github and then do a pull request to incorporate our changes from our current working branch to the develop branch.

```bash
git add -A
git commit -m 'feat: add new validation & summary stats
> Add validation function to ensure proper numeric vector input.
> Add summary stat functions to compute standard deviation and z-score.'
git push --set-upstream origin ch6
```

## `r fontawesome::fa("python")` example
