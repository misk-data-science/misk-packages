---
title: "Delivering Data Science Products via Packages"
author: "Misk Academy"
date: "2020-6-26"
output:
  xaringan::moon_reader:
    includes:
      after_body: insert-logo.html
    css: ["custom.css", "style.css"]
    self_contained: false
    lib_dir: libs
    chakra: libs/remark-latest.min.js
    nature:
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    seal: false
---

class: misk-title-slide   
<a href="https://github.com/misk-data-science/misk-packages"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>


<br><br><br><br>
# .font120[Delivering Data Science Products<br>via Packages]

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Introduction]

---
# What are packages?

* Packages are the fundamental units of reproducible R and Python code. 

* They include reusable components, the documentation that describes how to use them, requirements to ensure the user can apply them and tests to ensure consistent and reliable functionality.


```{block, type='note'}
.font80[
People often use the terms "package" and "library" synonymously.

- __package__: generally refers to source code that is bundled up in a way that a package manager can host. [PyPI](https://pypi.org/) and [CRAN](https://cran.r-project.org/) are the two primary public package managers for Python and R. When you `pip install pkg` (Python) or `install.packages("pkg")` (R) you are installing the __pkg__ package from a package manager onto a computer.

- __library__: generally refers to a centralized location on an operating system where installed package source code resides and can be imported into a current session (i.e. /usr/lib/R/library).  When you use `pip list` (Python) or `installed.packages()` (R) you will see a list of _installed_ packages, which we refer to as libraries. When you run `sys.path` (Python) or `.libPaths()` (R) you will get the path to the library where your installed packages are stored.
]
```


---
# Packaging

.pull-left.font120[

.bold[Why?]

- To share with others

- Reproducibility

- Track changes

- Communication

- Reliability

- Production
]

--

.pull-left.font120[

.bold[Why not?]

- Exploratory analysis

- One-off projects

- Small scripts

<br>
.center.font90.red[___Although the above type of work may not justify a package, it often still justifies good software engineering practices such as modularity and unit tests!___]

]

---
# Things to be aware of

* Several approaches and strategies to writing packages

* This course demonstrates commonly accepted best practices

* __Objective__: provide you with a short runway to writing packages as quickly as possible while following commonly used best practices

--

<br>

```{block, type='note'}
This is a lot to learn, but don’t feel overwhelmed. Start with a minimal subset of useful features and build up over time.
```

---
# Conventions used throughout

.font120[
- Python: `r fontawesome::fa("python")`
- R: `r fontawesome::fa("r-project")`
]

```{block, type = "tip"}
Signifies a tip or suggestion
```

```{block, type = "note"}
Signifies a general note
```

```{block, type = "warning"}
Signifies a warning or caution
```

---
# Exercises

<br>

1. Skim the table of contents for the following "official guides" to `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")` packaging. Do not worry about reading the details but realize that these are good sources to start looking at when you have questions about certain aspects of packaging.
   - `r fontawesome::fa("r-project")`: [Creating R Extensions](https://cran.r-project.org/doc/manuals/R-exts.html#Creating-R-packages)
   - `r fontawesome::fa("python")`: [Python Packaging User Guide](https://packaging.python.org/)

2. Identify two popular `r fontawesome::fa("r-project")` packages and explain why packaging these capabilities is beneficial.

3. Identify two popular `r fontawesome::fa("python")` packages and explain why packaging these capabilities is beneficial.

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Package Structure]

---
# Basic required files

.pull-left[

Minimum files required or highly suggested:

* Package metadata

* Source code directory

* Test directory

* Documentation directory

* License file

* Changelog

* README

* Other various config or requirement files

]

.pull-right[

```sh
.
├── package metadata file
├── source code directory
│   ├── script 1
│   ├── script 2
│   └── script n
├── test directory
│   ├── script 1
│   ├── script 2
│   └── script n
├── documentation directory
│   └── various doc files
├── license file
├── changelog file
├── README
└── other various config files and components
```

]

---
class: inverse, hide-logo

<br><br><br><br><br>
.center.white.font200[Let's assume a package called .bold.red[mypkg]]

---
# `r fontawesome::fa("r-project", fill = "white")` file structure

.pull-left[

Unique items here are:

- __DESCRIPTION__: This is the file that contains the primary package metadata.
- __R/__: The R directory is where all the source code resides.
- __NEWS__: It is common convention in many R packages to title the changelog as "NEWS".

]

.pull-right[

```sh
mypkg
├── DESCRIPTION
├── R/
├── tests/
├── docs/
├── LICENSE
├── NEWS
└── README
```

]

---
# `r fontawesome::fa("python", fill = "white")` file structure

.pull-left[

Unique items here are:

- __setup.py__: This is the file that contains the primary package metadata.
- __src/__: The src directory is where all the source code resides.

]

.pull-right[

```sh
mypkg
├── setup.py
├── src/
├── tests/
├── docs/
├── LICENSE
├── CHANGELOG
└── README
```

]

---
# Exercises

1. Look at the package structure for the `r fontawesome::fa("r-project")` package [tidyr](https://github.com/tidyverse/tidyr/)
   - Do all the files exist that were discussed in this module?
   - Take a quick glance at each of the files discussed in this section.
   - What additional files are present?

2. Look at the package structure for the `r fontawesome::fa("python")` package [pytest](https://github.com/pytest-dev/pytest)
   - Do all the files exist that were discussed in this module?
   - Take a quick glance at each of the files discussed in this section.
   - What additional files are present?

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Development Workflow]

---
# Typical workflow

.pull-left[

.center.bold[Initial Development]

1. Identify package name

2. Create package structure

3. Enable version control

4. Setup virtual environment

5. Add new functionality (TDD style)

6. Document

7. Version control
]

--

.pull-right[

.center.bold[Ongoing Development]

1. .opacity10[Identify package name]

2. .opacity10[Create package structure]

3. .opacity10[Enable version control]

4. .opacity10[Setup virtual environment]

5. Add new functionality (TDD style)

6. Document

7. Version control

]

---
# Package name

- Easy to remember

- Follow the respective languages idiomatic approach to naming

- Should not already exist.

- Certain requirements we need to adhere to
  - `r fontawesome::fa("r-project")` your name can contain a `.` but not a `-` or `_`
  - `r fontawesome::fa("python")` your name can contain all three but not recommended
  - In both languages you can combine upper and lowercase letters in the name.

- Examples of good names:
  - numpy
  - dplyr
  - pandas
  - keras

---
# Package structure

Where will the package live on your operating system?

- Should be distinct from where installed packages live

- Typically designate a directory inside their home directory for `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")` (source) packages

- E.g. `~/Desktop/Packages/` or `/r/packages` and `/python/packages`

```{block, type = "note"}
There are manual approaches to create the initial package structure but we'll use a tool to help automate this procedure. We'll cover this within our working examples.
```

---
# Enable version control

.scrollable90[
Most package development never resides solely on one operating system nor with only one developer.

- [GitHub](https://github.com/), 
- [GitLab](https://gitlab.com/), 
- [Azure Repos](https://azure.microsoft.com/en-us/services/devops/repos/)

.bold[Step 1]: connect our local git repository to a remote repository so we can push, pull, and merge updates we make to the package

.bold[Step 2]: set up a proper branching method for our work

- __master__ branch is the "production" release branch.
- __develop__ branch is the main branch where the source code always reflects a state with the latest delivered development changes for the next release.
- __supporting branches__ are the branches where we do the majority of our work. These are the branches where we create new fixtures, fix bugs, improve documentation.

```{block, type='tip'}
If you are unfamiliar with git and branching then we recommend these tutorials to get started:

- [Understanding the GitHub flow](https://guides.github.com/introduction/flow/)
- [A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)
```
]

---
# Virtual environments

- Virtual environments create an isolated environment for our project

- Each project can have its own dependencies, regardless of what dependencies every other project has

- Creates better reliability during the development process.

```{block, type='tip'}
.bold[It is a best practice to always do your development work in virtual environments.] To learn more about virtual environments we suggest starting with the following tutorials:

- [Python Virtual Environments: A Primer](https://realpython.com/python-virtual-environments-a-primer/)
- [renv: Project Environments for R](https://rstudio.github.io/renv/articles/renv.html)
```

---
# Add new functionality

.scrollable90[

When adding new functionality we recommend following a .bold[test-driven development] (TDD) approach

1. __Add a test__: In TDD, each new feature or bug fix begins with writing a test. This test defines a function, improvements of a function, or a case in which a function results in a bug.
2. __Run test(s) and make sure the new test fails__: Before writing any source code, run the new test to ensure that it fails.
3. __Write the code__: The next step is to write some code that causes the test to pass. The new code written at this stage is not perfect and may, for example, pass the test in an inelegant way. That is acceptable because it will be improved and honed in Step 5.
4. __Run tests__: If all test cases now pass, the programmer can be confident that the new code meets the test requirements, and does not break or degrade any existing features. If they do not, the new code must be adjusted until they do.
5. __Refactor code__: Once the source code passes the test, you should spend time refactoring and cleaning it up. A growing code base can quickly get out of control. This step ensures you take the time to reduce [tech debt](https://en.wikipedia.org/wiki/Technical_debt).
6. __Repeat__: Starting with another new test, the cycle is then repeated to push forward the functionality of the source code.

```{block, type='tip'}
If you are interested in learning more about the TDD philosophy we recommend the following books:

- [The Pragramatic Programmer](https://www.amazon.com/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052/ref=dp_ob_title_bk) (Ch. 41)
- [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_bxgy_img_2/134-3713013-8748161?_encoding=UTF8&pd_rd_i=0132350882&pd_rd_r=c66a8eb8-13a3-4246-bf5c-47bff29f3be6&pd_rd_w=m2kCB&pd_rd_wg=NqeJv&pf_rd_p=4e3f7fc3-00c8-46a6-a4db-8457e6319578&pf_rd_r=R46745MCZ1C0V1ZD3QS4&psc=1&refRID=R46745MCZ1C0V1ZD3QS4) (Ch. 9)
- [Test Driven Development](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)
```

]

---
# Document

Once your new functionality is successfully passing tests and has been refactored, you should make sure any necessary documentation is added or updated:

- function specific documentation, 

- module level documentation, 

- any code in example notebooks or vignettes,

- package website

---
# Version control

Lastly, we need to now save our work to our remote repository. This typically includes:

- staging, 

- commiting and 

- pushing our changes. 

- Depending on the stage of our work we may be ready to do a pull request into the main development branch.

--

<br><br>

.center.bold.red[Seems like a lot of steps to keep track of. Often, this feels more convoluted on paper than when you are actually implementing so let's work through some examples!]

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("r-project", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/03-workflow.html#_workflow_example)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("python", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/03-workflow.html#_workflow_example5)

---
# Exercises

<br>

Pick at least one exercise for R and one for Python to complete. Write up a summary of the findings and share with a colleague:

* R blended learning exercises
   1. Read [Navigating the R Package Universe](https://journal.r-project.org/archive/2018/RJ-2018-058/RJ-2018-058.pdf).
   2. Watch David Robinson's screencast on [creating an R data package](https://www.youtube.com/watch?edufilter=NULL&v=F4oUJp76KUY).
   
* Python blended learning exercises
   1. Read [Hitchhiker's Guide to Python: Packaging Your Code](https://docs.python-guide.org/shipping/packaging/).
   2. Read [Python's New Package Landscape](http://andrewsforge.com/article/python-new-package-landscape/).

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Package Metadata]

---
# Metadata considerations

.pull-left[

- Name & package description

- Author & contact info

- Dependencies

- Versioning

- License

- Project source

- Other

]

.pull-right[


]

---
# Metadata considerations

.pull-left[

- .bold[Name & package description]

- Author & contact info

- Dependencies

- Versioning

- License

- Project source

- Other

]

.pull-right[

* Name of the package,

* A shorter, one line description of the package provides,

* A longer, multi-line description of the package. This is the elevator pitch of the key things that your package does and how important it is to others.

]

---
# Metadata considerations

.pull-left[

- Name & package description

- .bold[Author & contact info]

- Dependencies

- Versioning

- License

- Project source

- Other

]

.pull-right[

- Minimum: primary author and email contact info

- Optionally provide additional authors and contributors along with their contact info

- Can even specify corporation relationships if necessary

]

---
# Metadata considerations

.pull-left[

- Name & package description

- Author & contact info

- .bold[Dependencies]

- Versioning

- License

- Project source

- Other

]

.pull-right[

- Language version dependency

- Required package dependencies

- Suggested package dependencies

- Developer dependencies

]

---
# Metadata considerations

.pull-left[

- Name & package description

- Author & contact info

- Dependencies

- .bold[Versioning]

- License

- Project source

- Other

]

.pull-right[

We advise using a [Semantic Versioning](https://semver.org/) approach 

`<MAJOR>.<MINOR>.<PATCH>` (i.e. 0.9.1, 1.4.0)

- `<MAJOR>` version when you make incompatible API changes. This signals that your updates will likely effect many users and will cause breaking changes to users' prior code. 
- `<MINOR>` version when you add functionality in a backwards compatible manner. This often includes adding a new feature that does not effect the existing code base.
- `<PATCH>` version when you make backwards compatible bug fixes.

]

---
# Metadata considerations
.scrollable90[
.pull-left[

- Name & package description

- Author & contact info

- Dependencies

- Versioning

- .bold[License]

- Project source

- Other

]

.pull-right[

The License field can be either a standard abbreviation for an open source license, like GPL-2 or BSD, or a pointer to a file containing more information, file `LICENSE`.

- [MIT](https://tldrlegal.com/license/mit-license): This is a simple and permissive license. It lets people use and freely distribute your code subject to only one restriction: the license must always be distributed with the code.
- [GPL-2](https://tldrlegal.com/license/gnu-general-public-license-v2) or [GPL-3](https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3)): These are “copy-left” licenses. This means that anyone who distributes your code in a bundle must license the whole bundle in a GPL-compatible way. Additionally, anyone who distributes modified versions of your code (derivative works) must also make the source code available. GPL-3 is a little stricter than GPL-2, closing some older loopholes.
- [CC0](https://tldrlegal.com/license/creative-commons-cc0-1.0-universal): It relinquishes all your rights on the code and data so that it can be freely used by anyone for any purpose. This is sometimes called putting it in the public domain, a term which is neither well-defined nor meaningful in all countries.

```{block, type='tip'}
If you’d like to learn more about other common licenses, Github’s [choosealicense.com](http://choosealicense.com/licenses/) is a good place to start. Another good resource is https://tldrlegal.com/, which explains the most important parts of each license.
```

]]

---
# Metadata considerations

.pull-left[

- Name & package description

- Author & contact info

- Dependencies

- Versioning

- License

- .bold[Project source]

- Other

]

.pull-right[

It is common to include URLs to direct users to:

- Where the source code resides (i.e. Github repo)
- Where to post bugs, feature requests, etc. (i.e. Github issues)

We may also want to point people to a package documentation website, the changelog, or other URLs that host important package information.

]

---
# Metadata considerations

.pull-left[

- Name & package description

- Author & contact info

- Dependencies

- Versioning

- License

- Project source

- .bold[Other]

]

.pull-right[

As you'll see in the next couple sections, there are additional types of metadata that we can include such as deploying data or other files (i.e. LICENSE) with you package. However, the items listed in the previous section are the primary forms of metadata that we want to ensure we include.

]

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("r-project", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/05-metadata.html#_package_metadata_example)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("python", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/05-metadata.html#_package_metadata_example9)

---
# Exercises

.scrollable90[
* Check out the metadata for the [dplyr](https://github.com/tidyverse/dplyr) package.
   * What is the current version number?
   * Who was the original creator?
   * What kind of license does it have?
   * What R version does it require?
   * What kind of dependencies are glue, rlang, DBI and lobstr?
* Check out the metadata for the [pre-commit](https://github.com/pre-commit/pre-commit) package. Note that this package uses setup.cfg to hold its metadata.
   * What is the current version number?
   * Who is the author?
   * What kind of license does it have?
   * What Oython version does it require?
   * Name 4 package dependencies of pre-commit?
* Building on to the initial R and Python packages you created in the portfolio building exercise:
   * Check out the LICENSE file in your package.
   * R package
      - Fill out the `Description` field for your package.
      - Add __dplyr__ as a required package dependency.
      - Add __purrr__ as a suggested package dependency.
      - Run `devtools::check()` to make sure the package builds successfully.
   * Python package
      - Create a `long_description` field for your package.
      - Add __numpy__ as a required package dependency.
      - Add __black__ as a developer suggested package dependency.
      - Activate your virtual environment, install your package in editable mode, ensure all developer dependencies are installed and rerun your test(s).
]

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Source Code]

---
# Organization

Organizing your source code provides many benefits such as:

- making the intentions of the code obvious,

- making it easy for others to contribute,

- making it easy for you to maintain,

- making it easy to debug,

- making it easy to expand.

```{block, type="note"}
There are very few strict requirements in how you organize your code but what follows are general best practices.
```

---
# Individual units

.pull-left[

Individual units of functionality 

- should be <font size="-2">small.</font>,
- should not require significant scrolling in your editor,
- should be very clear regarding the intention and functionality they are providing,
- should only _"do one thing"_.

```{block, type="tip"}
One way to know if a function is doing more than one thing is if you can extract another function from it with a name that is not merely a restatement of its implementation.
```

]

--

.pull-right[

Two main ways our code expands:

1. breadth: we add more functionality but not necessarily building onto existing functionality,

2. aggregation: we continue building onto existing functionality to create layers of abstraction.

]

---
# Expanding code breadth

* Expanding code breadth is easier to maintain. For our example package that currently has a `my_mean()` function, this could include adding new functions such as `my_median()` and  `my_mode()`. 

* When expanding code breadth the main thing you should consider is where to put the new functionality.

* Grouping like functionality into one file is good. For example, since `my_mean()`, `my_median()` and `my_mode()` are all forms of central tendencies we may put them in the same file while functions with other purposes (i.e. deviations) may go into a different file.

```{block, type='tip'}
While you're free to arrange functions into files as you wish, the two extremes are bad: don't put all functions into one file and don't put each function into its own separate file.
```

---
# Aggregating functionality

.pull-left[

* Often, we write code that builds on top of each other. 

* This is known as creating higher levels of abstraction. 

* For example, say we wanted to create a function that computes the z-score, which uses the mean and standard deviations. This is a higher level of abstraction and we should write our code in such a way that:
  1. our code reads like a top-down narrative,
  2. functionality is abstracted away and grouped at similar levels of abstraction.

]

.pull-right[

```python
# highest abstracted level
def z_score():
  pass
  
# next layer of abstractoin
def my_mean():
  pass
  
def my_sd():
  pass
  
# lowest level of abstraction
def validate_input():
  pass
```

]

---
# Naming is important

Naming is important but as our source code grows it becomes even moreso. Here are some good naming tips:

- If a file contains a single function, give the file the same name as the function.

- If a file contains multiple related functions, give it a concise, but descriptive name. For example, we could group `my_mean()`, `my_median()` and `my_mode()` together into a file named `central_tendencies`.

- Sometimes you have many helper functions in your source code that all support one primary user facing API functionality. Put the user-facing API function/class into a file named `main` or `main_api`.

- Many times people create a general `utils` file to hold general utility functions. This is not advised. Always try to find a proper home and name for all supporting functions. This is a [great read](https://breadcrumbscollector.tech/stop-naming-your-python-modules-utils/) explaining why.

- Deprecated functions should live in a file or directory that makes it obvious they are deprecated (i.e. prefix file name with `deprec-`).

---
# External vs internal

When developing packages, we often build functions with two main purposes:

1. External use: functions that are designed to be used by the end-user. This is the primary purpose of writing a package, to make some functionality easier for an end-user.

2. Internal use: functions that are designed to help you, the developer, write efficient and effect code. Internal functions are usually not intended for external use by end-users.

--

```{block, type="tip"}
Within both R and Python package you have the ability to make your functions be either externally or internally focused. In the examples that follow we will illustrate how but it is important that you apply the same rules to both external and internal functions - document and test __all__ your functions. Although not a requirement this will make your life and other developer's lives that want to contribute much easier.
```

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("r-project", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/06-source-code.html#_source_code_example)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("python", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/06-source-code.html#_source_code_example3)

---
# Exercises

<br>

1. With the R and Python packages you created in the portfolio builder, work through the [R](#rexample) and [Python](#pyexample) examples above to add new functionality to your package.

2. Fork one of your classmates packages and:
   - create a new branch,
   - add a new function (and associated unit test) that is unique to the existing functions,
   - add a new function (and associated unit test) that builds onto one of their existing functions,
   - create a pull request to add this new functionality to your classmates develop branch.

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Tests]

---
# Why test

Formalizing and automating the test structure and process helps with:

.scrollable90[
* __Fewer bugs__. Because you’re explicit about how your code should behave you will have fewer bugs. The reason why is a bit like the reason double entry book-keeping works: because you describe the behaviour of your code in two places, both in your code and in your tests, you are able to check one against the other. By following this approach to testing, you can be sure that bugs that you’ve fixed in the past will never come back to haunt you.

* __Better code structure__. Code that’s easy to test is usually better designed. This is because writing tests forces you to break up complicated parts of your code into separate functions that can work in isolation. This reduces duplication in your code. As a result, functions will be easier to test, understand and work with (it’ll be easier to combine them in new ways).

* __Easier restarts__. If you always finish a coding session by creating a failing test (e.g. for the next feature you want to implement), testing makes it easier for you to pick up where you left off: your tests will let you know what to do next.

* __Robust code__. If you know that all the major functionality of your package has an associated test, you can confidently make big changes without worrying about accidentally breaking something. For me, this is particularly useful when I think I have a simpler way to accomplish a task (usually the reason my solution is simpler is that I’ve forgotten an important use case!).
]

---
# What to test

.scrollable90[
* __Focus on testing the external interface to your functions__ - if you test the internal interface, then it’s harder to change the implementation in the future because as well as modifying the code, you’ll also need to update all the tests.

* Strive to __test each behaviour in one and only one test__. Then if that behavior later changes you only need to update a single test.

* You do not need to test _all_ of your code; however, we often __strive to test 85-95% of our code__. Focus your time on code that you’re not sure about, is fragile, or has complicated interdependencies. That said, we often find we make the most mistakes when we falsely assume that the problem is simple and doesn’t need any tests. So there is definitely a case for striving for 100% coverage.

* __Always write a test when you discover a bug or want to create a feature enhancement__. Start by writing the tests, and then write the code that makes them pass. This reflects an important problem solving strategy: start by establishing your success criteria, how you know if you’ve solved the problem.

* You should not only write tests that outline the successful expected outcome of a function but you should also __write tests to verify that expected messages, warnings, and errors are produced__.
]

---
# Test organization

* tests should live in a `tests/` directory at the root of the package

* test files for both languages should start with `test` (i.e. `test-validation.R`, `test_summary_stats.py`)

* Tests are organized hierarchically: expectations and assertions are grouped into tests which are organized in files:
   * An __expectation__ or __assertion__ is the atom of testing. It describes the expected result of a computation: Does it have the right value and right class? Does it produce error messages when it should? An expectation automates visual checking of results in the console. 
   * A __test__ groups together one or more expectations/assertions to test the output from a simple function, a range of possibilities for a single parameter from a more complicated function, or tightly related functionality from across multiple functions. This is why they are sometimes called unit as they test one unit of functionality.
   * A __test file__ groups together multiple related tests. How you organize tests within files is your discretion; however, one best practice suggests that for every source code script there is a companion, similarly named test script (i.e. `summary_stats.py` & `test_summary_stats.py`).

---
# Types of tests

Many types of tests; however, the most common ones you should be thinking of initially are:

.scrollable90[

* __unit tests__: 
   - test one unit of functionality
   - focus on the output from a single function
   - foundational building block functions of your package
   - should be fast so you can run them often and, preferablly not require any special environment to run them (i.e. a Spark session)

* __integration tests__: 
   - tests that focus on processes and/or components that combine functionality from across multiple functions
   - ensure that all the lower abstraction level functions work nicely with one another when combined

```{block, type="note"}
Often, integrated functionality becomes very large and sometimes can be slower to compute so it is not unusual for integration tests to be much slower than unit tests. However, we also do not need to run them as often as unit tests.
```
]

---
# Writing tests

.pull-left[

__Given-When-Then__ is a style of representing tests that can help guide you in writing your tests, make your tests more focused and better documented.

* The __given__ part describes the state of the world before you begin the behavior you're specifying in this scenario. You can think of it as the pre-conditions to the test.
* The __when__ section is the behavior that you're specifying, or the specific functionality you are applying to the given state of the world.
* Finally the __then__ section describes the changes you expect due to the specified behavior.

]

--

.pull-right[

A simple example is with our `my_mean()` function. In both languages we follow a common procedure:

1. __GIVEN__ a vector or list of integers from 0-10,
2. __WHEN__ we compute the mean value,
3. __THEN__ the result should be 5

]

---
# Additional resources

- Build your knowledge of general software testing philosophies:
   - [The Pragramatic Programmer](https://www.amazon.com/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052/ref=dp_ob_title_bk) (Ch. 41)
   - [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_bxgy_img_2/134-3713013-8748161?_encoding=UTF8&pd_rd_i=0132350882&pd_rd_r=c66a8eb8-13a3-4246-bf5c-47bff29f3be6&pd_rd_w=m2kCB&pd_rd_wg=NqeJv&pf_rd_p=4e3f7fc3-00c8-46a6-a4db-8457e6319578&pf_rd_r=R46745MCZ1C0V1ZD3QS4&psc=1&refRID=R46745MCZ1C0V1ZD3QS4) (Ch. 9)
   - [Test Driven Development](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)

- Learn more about implementing software testing in `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")`:
   - [Testing R Code](https://www.amazon.com/Testing-Code-Chapman-Hall-CRC/dp/1498763650)
   - [testthat documentation](https://testthat.r-lib.org/)
   - [Python Testing with pytest](https://www.amazon.com/Python-Testing-pytest-Effective-Scalable/dp/1680502409/ref=sr_1_3?keywords=Python+Testing+with+pytest&qid=1578174634&s=books&sr=1-3)
   - [Multiply your Testing Effectiveness with Parameterized Testing](https://us.pycon.org/2020/schedule/presentation/172/)
   - [pytest documentation](https://docs.pytest.org/en/latest/)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("r-project", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/08-testing.html#_testing_example)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("python", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/08-testing.html#_testing_example7)


---
# Exercises

<br>

1. With the R and Python packages you created in the portfolio builder, work through the [R](#rexample) and [Python](#pyexample) examples above to update your package's unit tests.

2. Fork one of your classmates packages and:
   - create a new branch,
   - review their unit tests, identify and add a new unit test,
   - add a new function (and associated unit test) that is unique to the existing functions.
   
3. Review the testing setup for the [usethis](https://github.com/r-lib/usethis) package. Identify something unique about this setup compared to the testing structure we outlined above.

4. Review the testing setup for the [scikit-learn](https://github.com/scikit-learn/scikit-learn/tree/master/sklearn/tests) package. Identify at least three tests where the documentation could be clearer by incorporating our __Given-When-Then__ approach. How would you write this improved documentation?

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Object documentation]

---
# Levels of documentation

Multiple forms of documentation:

- __Package-level documentation__: Top level description for what your package does and can point users to additional resources if necessary.

- __Module-level documentation__: More common in `r fontawesome::fa("python")` than `r fontawesome::fa("r-project")` and helps to describe the purpose and contents of an individual module within a package.

- __Function-level documentation__: The function documentation that you have already been exposed to in earlier modules.

<br>

```{block, type='tip'}
Documentation is one of the most important aspects of a good package
```

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("r-project", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/09-object-docs.html#_object_documentation_example)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("python", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/09-object-docs.html#_object_documentation_example2)

---
# Exercises

Focusing on the R and Python packages you created in the portfolio builder:

1. Fork one of your classmates packages, create a new branch, add package-level documentation and create a pull request.
2. Fork another classmates packages, create a new branch, add module-level documentation and create a pull request.
3. Fork another classmates packages, create a new branch, add function-level documentation and create a pull request.
4. __Optional__: Review the referenced documentation for [type-hints](#typehints) add type hints to your existing code. Be sure to run [mypy](https://mypy.readthedocs.io/en/stable/) on your package to ensure your type hints are implemented correctly.

```{block, type='note'}
As a reviewer of the above pull requests, be sure to thoroughly review the contributors changes. It is ok to ask for edits or corrections on a pull request. And as a submitter of the above pull requests, if the maintainer requests edits or even rejects your pull request, don't take this personally. Listen to their reasons why, learn from them and move on.
```

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Changelog]



---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[README]



---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Long-form Documentation]



---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Package Website]



---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Other Components]



---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Continuous Integration]
