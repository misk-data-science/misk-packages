---
title: "Delivering Data Science Products via Packages"
author: "Misk Academy"
date: "2020-6-26"
output:
  xaringan::moon_reader:
    includes:
      after_body: insert-logo.html
    css: ["custom.css", "style.css"]
    self_contained: false
    lib_dir: libs
    chakra: libs/remark-latest.min.js
    nature:
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    seal: false
---

class: misk-title-slide   
<a href="https://github.com/misk-data-science/misk-packages"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>


<br><br><br><br>
# .font120[Delivering Data Science Products<br>via Packages]

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Introduction]

---
# What are packages?

* Packages are the fundamental units of reproducible R and Python code. 

* They include reusable components, the documentation that describes how to use them, requirements to ensure the user can apply them and tests to ensure consistent and reliable functionality.


```{block, type='note'}
.font80[
People often use the terms "package" and "library" synonymously.

- __package__: generally refers to source code that is bundled up in a way that a package manager can host. [PyPI](https://pypi.org/) and [CRAN](https://cran.r-project.org/) are the two primary public package managers for Python and R. When you `pip install pkg` (Python) or `install.packages("pkg")` (R) you are installing the __pkg__ package from a package manager onto a computer.

- __library__: generally refers to a centralized location on an operating system where installed package source code resides and can be imported into a current session (i.e. /usr/lib/R/library).  When you use `pip list` (Python) or `installed.packages()` (R) you will see a list of _installed_ packages, which we refer to as libraries. When you run `sys.path` (Python) or `.libPaths()` (R) you will get the path to the library where your installed packages are stored.
]
```


---
# Packaging

.pull-left.font120[

.bold[Why?]

- To share with others

- Reproducibility

- Track changes

- Communication

- Reliability

- Production
]

--

.pull-left.font120[

.bold[Why not?]

- Exploratory analysis

- One-off projects

- Small scripts

<br>
.center.font90.red[___Although the above type of work may not justify a package, it often still justifies good software engineering practices such as modularity and unit tests!___]

]

---
# Things to be aware of

* Several approaches and strategies to writing packages

* This course demonstrates commonly accepted best practices

* __Objective__: provide you with a short runway to writing packages as quickly as possible while following commonly used best practices

--

<br>

```{block, type='note'}
This is a lot to learn, but don’t feel overwhelmed. Start with a minimal subset of useful features and build up over time.
```

---
# Conventions used throughout

.font120[
- Python: `r fontawesome::fa("python")`
- R: `r fontawesome::fa("r-project")`
]

```{block, type = "tip"}
Signifies a tip or suggestion
```

```{block, type = "note"}
Signifies a general note
```

```{block, type = "warning"}
Signifies a warning or caution
```

---
# Exercises

<br>

1. Skim the table of contents for the following "official guides" to `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")` packaging. Do not worry about reading the details but realize that these are good sources to start looking at when you have questions about certain aspects of packaging.
   - `r fontawesome::fa("r-project")`: [Creating R Extensions](https://cran.r-project.org/doc/manuals/R-exts.html#Creating-R-packages)
   - `r fontawesome::fa("python")`: [Python Packaging User Guide](https://packaging.python.org/)

2. Identify two popular `r fontawesome::fa("r-project")` packages and explain why packaging these capabilities is beneficial.

3. Identify two popular `r fontawesome::fa("python")` packages and explain why packaging these capabilities is beneficial.

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Package Structure]

---
# Basic required files

.pull-left[

Minimum files required or highly suggested:

* Package metadata

* Source code directory

* Test directory

* Documentation directory

* License file

* Changelog

* README

* Other various config or requirement files

]

.pull-right[

```sh
.
├── package metadata file
├── source code directory
│   ├── script 1
│   ├── script 2
│   └── script n
├── test directory
│   ├── script 1
│   ├── script 2
│   └── script n
├── documentation directory
│   └── various doc files
├── license file
├── changelog file
├── README
└── other various config files and components
```

]

---
class: inverse, hide-logo

<br><br><br><br><br>
.center.white.font200[Let's assume a package called .bold.red[mypkg]]

---
# `r fontawesome::fa("r-project", fill = "white")` file structure

.pull-left[

Unique items here are:

- __DESCRIPTION__: This is the file that contains the primary package metadata.
- __R/__: The R directory is where all the source code resides.
- __NEWS__: It is common convention in many R packages to title the changelog as "NEWS".

]

.pull-right[

```sh
mypkg
├── DESCRIPTION
├── R/
├── tests/
├── docs/
├── LICENSE
├── NEWS
└── README
```

]

---
# `r fontawesome::fa("python", fill = "white")` file structure

.pull-left[

Unique items here are:

- __setup.py__: This is the file that contains the primary package metadata.
- __src/__: The src directory is where all the source code resides.

]

.pull-right[

```sh
mypkg
├── setup.py
├── src/
├── tests/
├── docs/
├── LICENSE
├── CHANGELOG
└── README
```

]

---
# Exercises

1. Look at the package structure for the `r fontawesome::fa("r-project")` package [tidyr](https://github.com/tidyverse/tidyr/)
   - Do all the files exist that were discussed in this module?
   - Take a quick glance at each of the files discussed in this section.
   - What additional files are present?

2. Look at the package structure for the `r fontawesome::fa("python")` package [pytest](https://github.com/pytest-dev/pytest)
   - Do all the files exist that were discussed in this module?
   - Take a quick glance at each of the files discussed in this section.
   - What additional files are present?

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Development Workflow]

---
# Typical workflow

.pull-left[

.center.bold[Initial Development]

1. Identify package name

2. Create package structure

3. Enable version control

4. Setup virtual environment

5. Add new functionality (TDD style)

6. Document

7. Version control
]

--

.pull-right[

.center.bold[Ongoing Development]

1. .opacity10[Identify package name]

2. .opacity10[Create package structure]

3. .opacity10[Enable version control]

4. .opacity10[Setup virtual environment]

5. Add new functionality (TDD style)

6. Document

7. Version control

]

---
# Package name

- Easy to remember

- Follow the respective languages idiomatic approach to naming

- Should not already exist.

- Certain requirements we need to adhere to
  - `r fontawesome::fa("r-project")` your name can contain a `.` but not a `-` or `_`
  - `r fontawesome::fa("python")` your name can contain all three but not recommended
  - In both languages you can combine upper and lowercase letters in the name.

- Examples of good names:
  - numpy
  - dplyr
  - pandas
  - keras

---
# Package structure

Where will the package live on your operating system?

- Should be distinct from where installed packages live

- Typically designate a directory inside their home directory for `r fontawesome::fa("r-project")` and `r fontawesome::fa("python")` (source) packages

- E.g. `~/Desktop/Packages/` or `/r/packages` and `/python/packages`

```{block, type = "note"}
There are manual approaches to create the initial package structure but we'll use a tool to help automate this procedure. We'll cover this within our working examples.
```

---
# Enable version control

.scrollable90[
Most package development never resides solely on one operating system nor with only one developer.

- [GitHub](https://github.com/), 
- [GitLab](https://gitlab.com/), 
- [Azure Repos](https://azure.microsoft.com/en-us/services/devops/repos/)

.bold[Step 1]: connect our local git repository to a remote repository so we can push, pull, and merge updates we make to the package

.bold[Step 2]: set up a proper branching method for our work

- __master__ branch is the "production" release branch.
- __develop__ branch is the main branch where the source code always reflects a state with the latest delivered development changes for the next release.
- __supporting branches__ are the branches where we do the majority of our work. These are the branches where we create new fixtures, fix bugs, improve documentation.

```{block, type='tip'}
If you are unfamiliar with git and branching then we recommend these tutorials to get started:

- [Understanding the GitHub flow](https://guides.github.com/introduction/flow/)
- [A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/)
```
]

---
# Virtual environments

- Virtual environments create an isolated environment for our project

- Each project can have its own dependencies, regardless of what dependencies every other project has

- Creates better reliability during the development process.

```{block, type='tip'}
.bold[It is a best practice to always do your development work in virtual environments.] To learn more about virtual environments we suggest starting with the following tutorials:

- [Python Virtual Environments: A Primer](https://realpython.com/python-virtual-environments-a-primer/)
- [renv: Project Environments for R](https://rstudio.github.io/renv/articles/renv.html)
```

---
# Add new functionality

.scrollable90[

When adding new functionality we recommend following a .bold[test-driven development] (TDD) approach

1. __Add a test__: In TDD, each new feature or bug fix begins with writing a test. This test defines a function, improvements of a function, or a case in which a function results in a bug.
2. __Run test(s) and make sure the new test fails__: Before writing any source code, run the new test to ensure that it fails.
3. __Write the code__: The next step is to write some code that causes the test to pass. The new code written at this stage is not perfect and may, for example, pass the test in an inelegant way. That is acceptable because it will be improved and honed in Step 5.
4. __Run tests__: If all test cases now pass, the programmer can be confident that the new code meets the test requirements, and does not break or degrade any existing features. If they do not, the new code must be adjusted until they do.
5. __Refactor code__: Once the source code passes the test, you should spend time refactoring and cleaning it up. A growing code base can quickly get out of control. This step ensures you take the time to reduce [tech debt](https://en.wikipedia.org/wiki/Technical_debt).
6. __Repeat__: Starting with another new test, the cycle is then repeated to push forward the functionality of the source code.

```{block, type='tip'}
If you are interested in learning more about the TDD philosophy we recommend the following books:

- [The Pragramatic Programmer](https://www.amazon.com/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052/ref=dp_ob_title_bk) (Ch. 41)
- [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_bxgy_img_2/134-3713013-8748161?_encoding=UTF8&pd_rd_i=0132350882&pd_rd_r=c66a8eb8-13a3-4246-bf5c-47bff29f3be6&pd_rd_w=m2kCB&pd_rd_wg=NqeJv&pf_rd_p=4e3f7fc3-00c8-46a6-a4db-8457e6319578&pf_rd_r=R46745MCZ1C0V1ZD3QS4&psc=1&refRID=R46745MCZ1C0V1ZD3QS4) (Ch. 9)
- [Test Driven Development](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)
```

]

---
# Document

Once your new functionality is successfully passing tests and has been refactored, you should make sure any necessary documentation is added or updated:

- function specific documentation, 

- module level documentation, 

- any code in example notebooks or vignettes,

- package website

---
# Version control

Lastly, we need to now save our work to our remote repository. This typically includes:

- staging, 

- commiting and 

- pushing our changes. 

- Depending on the stage of our work we may be ready to do a pull request into the main development branch.

--

<br><br>

.center.bold.red[Seems like a lot of steps to keep track of. Often, this feels more convoluted on paper than when you are actually implementing so let's work through some examples!]

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("r-project", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/03-workflow.html#_workflow_example)

---
class: inverse, hide-logo

<br><br><br>
[.center.white.font300[
`r fontawesome::fa("python", fill = "white")` example
]](https://misk-data-science.github.io/misk-packages/notebooks/03-workflow.html#_workflow_example5)

---
# Exercises

<br>

Pick at least one exercise for R and one for Python to complete. Write up a summary of the findings and share with a colleague:

* R blended learning exercises
   1. Read [Navigating the R Package Universe](https://journal.r-project.org/archive/2018/RJ-2018-058/RJ-2018-058.pdf).
   2. Watch David Robinson's screencast on [creating an R data package](https://www.youtube.com/watch?edufilter=NULL&v=F4oUJp76KUY).
   
* Python blended learning exercises
   1. Read [Hitchhiker's Guide to Python: Packaging Your Code](https://docs.python-guide.org/shipping/packaging/).
   2. Read [Python's New Package Landscape](http://andrewsforge.com/article/python-new-package-landscape/).

---
class: misk-section-slide 

<br><br><br><br><br><br><br>
.bold.font250[Package Metadata]
