[
["index.html", "Delivering Data Science Products via Packages Chapter 1 Welcome Who should read this What you need for this book Conventions used in this book Feedback Acknowledgments", " Delivering Data Science Products via Packages 2020-05-25 Chapter 1 Welcome Packages are the fundamental units of reproducible R and Python code. They include reusable components, the documentation that describes how to use them, requirements to ensure the user can apply them and tests to ensure consistent and reliable functionality. In this book you’ll learn how to turn your code into packages so that you, your teammates, and others can easily download and use. Writing a package can seem overwhelming at first. So start with the basics and improve it over time. It doesn’t matter if your first version isn’t perfect as long as the next version is better. Who should read this TBD This module makes a few assumptions of your established knowledge regarding your programming skills. Below are some important assumptions made and resources to read through if you feel inadequately prepared: Complete after rest of material is finalized. Assumptions Resource Resource You should be familiar with… You should be familiar with… You should be familiar with… You should be familiar with… What you need for this book TBD Conventions used in this book The following typographical conventions are used in this book: strong italic: indicates new terms, bold: indicates package &amp; file names, inline code: monospaced highlighted text indicates functions or other commands that could be typed literally by the user, code chunk: indicates commands or other text that could be typed literally by the user 1 + 2 ## [1] 3 We will also refer to both R and Python throughout. When discussing one or the other we will typically label with the appropriate icons: Python: R: In addition to the general text used throughout, you will notice the following code chunks: Signifies a tip or suggestion Signifies a general note Signifies a warning or caution Feedback Reader comments are greatly appreciated. To report errors or bugs please post an issue at https://github.com/misk-data-science/misk-packages/issues. Acknowledgments TBD "],
["intro.html", "Chapter 2 Introduction to Packaging 2.1 Why is packaging important 2.2 When packaging might not be needed 2.3 An opinionated approach", " Chapter 2 Introduction to Packaging Often, small snippets of code grow in usefulness and importance, which creates a need to share and distribute their contents. and libraries require packaging, otherwise distributing code becomes problematic and brittle. A package bundles together code, data, documentation, and tests, and is easy to share with others. People often use the terms “library” and “package” synonymously. Although there are some semantical differences between R and Python, here is how you can think of the two terms: library: generally refers to source code that has been installed on an operating system in a centralized location and can be imported into a current session. When you use pip list (Python) or installed.packages() (R) you will see a list of installed packages, which we refer to as libraries. When you import pkg (Python) or library(pkg) (R) you are loading the pkg library into your current session for use. package: generally refers to source code that is bundled up in a way that a package manager can host. PyPI and CRAN are the two primary public package managers for Python and R. When you pip install pkg (Python) or install.packages(“pkg”) (R) you are installing the pkg package from a package manager onto a computer. 2.1 Why is packaging important Why write a package? To share with others: Bundling your code into a package makes it easy for other people to use it, because like you, they already know how to use packages. If your code is in a package, any or user can easily download it, install it and learn how to use it. To make processes reproducible: When certain code processes are repeated, rather than copy-n-pasting (error prone!) packaging helps to ensure the same procedures are executed in the same way. This leads to standardized tools for standardized conventions and can save you and others time. To track changes: Packaging helps to formulize version changes of a project. Versioning allows developers a way to communicate the type of changes made to a project (i.e. bug fixes versus feature enhancement). It also allows users to “pin” a specific version that works for their project. For example, although a current package may have a version 3.2.1, your project depends on specific functionality provided in version 2.9.7. Pinning allows you to request and use that specific version. To communicate with users: Beyond versioning, packaging helps with communication between developers and end-users. Detailed documentation helps the end-users implement the code, a change log can communcate the progression of a package over its versions, users can communicate to the developers regarding bugs they’ve found or suggested feature enhancements. To provide reliability: Packaging helps to modularize code in a way that allows for, and simplifies, testing procedures. This means as your source code grows, or as you get feedback from end-users, so should your test suite grow to help improve reliability of the code base. This results in code that is reliable and trustworthy. To deploy production work: You may have code that is never reused by others; however, the code is put into production to formalize the processesing and output of the code. Packaging your project is a great way to organize, maintain, and distribute your work into production. 2.2 When packaging might not be needed To be clear, it is not necessary to package your code to address all the bullets in the previous section; but it will definitely make them easier to achieve. However, there are times when writing a package is not necessary. For example: Exploratory analysis: The exploratory phase of a project is very interactive and contains many unknowns. You may find yourself repeating some code, which may be a good time to write and reuse small functions. However, this is not the phase to start writing a package. It’s best to wait and see what results from your exploratory analysis. If there are steps in the process (i.e. data prep, model execution) that you later determine are common steps that will often be repeated in the future then a package may result from post-exploration project review. One-off projects: Many times we perform one-off ad-hoc projects. Sometimes we may be able to abstract some steps in these projects that may be repeated but often these projects contain very unique steps that are not often repeated. You most likely will use packages in your analysis but writing a package based on a one-off project is rarely a good use of time. Small scripts: Sometimes a simple , , or Bash script can go a long way and serve your primary purpose. Small individual scripts can be easy to build, execute and orchestrate; however, if you notice this small script starting to grow in size and use then it’s time to start thinking of converting it to a package. Although the above type of work may not justify a package, it often still justifies good software engineering practices such as modularity and unit tests! 2.3 An opinionated approach It is important to understand that there are several approaches and strategies to writing packages. Even within a single language there are different ways to structure a package. Consequently, understand that this book demonstrates the best practices we have found for developing, maintaining, and distributing packages. Our goal is to provide you with a short runway to writing packages as quickly as possible while following commonly used best practices. This is a lot to learn, but don’t feel overwhelmed. Start with a minimal subset of useful features and build up over time. As you write more packages you will begin to learn the lower-level details and alternative options. Do not shy away from these details as we highly recommend that you learn them. In fact, below are some additional resources that will take you to the official R and Python packaging documentation. Realize that the details in these documents can make them challenging to read. That is ok and to be expected. Our suggestion is to get the basics down, which we cover in this book, and slowly expand your knowledge base by writing more packages. : Creating R Extensions : Python Packaging User Guide "],
["structure.html", "Chapter 3 Package Structure 3.1 3.2 ", " Chapter 3 Package Structure Packages have a specific structure required to be bundable, deployable, and usable. There are a set of minimum files required for both and packages but you will often see additional files in packages. Though how these files are actually named will differ between and , the organization follows a very similar pattern. The primary files and directories you will be concerned about include: Package metadata: Every package requires important metadata about the package. This file will declare various information such as package name, description, dependencies, author(s), contact information and more. Chapter 5 will discuss the details of this file. Source code directory: This is the directory that contains all the source code for end-user functionality. Here you will organize your classes, functions, etc. into one or more .R / .py scripts. Chapter 6 will discuss requirements, approaches and best practices for organizing this directory. Test directory: Every package should always contain a testing framework. These tests should include a minimum of unit tests but can also contain integration or environment specific tests. Chapter 7 will discuss the most common test approaches for and . Documentation directory: Although not necessary, good packages often will have detailed documentation hosted as a static website. These files are generally kept in a /docs folder. Chapter 11 will discuss how to make beautiful websites for your package. License file: Specifies who can and cannot use your package. This file is related to specifications made in the metadata file and will be discussed in Chapter 5. Changelog: A changelog is a log or record of all notable changes made to a project. We will discuss the changelog in Chapter 9. README: The README is often one of the first files a user sees when going to the source code location (typically Github). A good README will provide useful instructions to get started using the package quickly and also where to go to find more detailed information. We will discuss what a good README looks like in Chapter 10. Other various config or requirement files: You will often see additional files in packages. These may be various configuration files or other package components. Many of these you will be introduced along the way through this book and others will be explicitly discussed in Chapter 12. This general structure will look like the following and the sections that follow will illustrate and describe the exact structure setup for each language. . ├── package metadata file ├── source code directory │ ├── script 1 │ ├── script 2 │ └── script n ├── test directory │ ├── script 1 │ ├── script 2 │ └── script n ├── documentation directory │ └── various doc files ├── license file ├── changelog file ├── README └── other various config files and components For the sections that follow let’s assume we are creating a package called mypkg. 3.1 Within R, the basic structure of your package will look like the following. The unique items here are: DESCRIPTION: This is the file that contains the primary package metadata. R/: The R directory is where all the source code resides. NEWS: It is common convention in many R packages to title the changelog as “NEWS”. mypkg ├── DESCRIPTION ├── R ├── tests ├── docs ├── LICENSE ├── NEWS └── README The rest of the files are consistent with the previous section. As you’ll see in the next chapter, additional files will be produced when we build the package but these are the primary directories and files to get going with an R package. 3.2 Within Python, the basic structure of your package will look like the following. The unique items here are: setup.py: This is the file that contains the primary package metadata. src/: The src directory is where all the source code resides. mypkg ├── setup.py ├── src ├── tests ├── docs ├── LICENSE ├── CHANGELOG └── README The rest of the files are consistent with the first section. As you’ll see in the next chapter, additional files often included to help configure the developer environment for a package but these are the primary directories and files to create a baseline Python package. "],
["workflow.html", "Chapter 4 Development Workflow 4.1 4.2 ", " Chapter 4 Development Workflow Discuss the basic developer workflow for packages… virtual environments TDD adding functionality documenting running tests etc. 4.1 4.2 "],
["metadata.html", "Chapter 5 Package Metadata 5.1 5.2 ", " Chapter 5 Package Metadata Dependencies (required vs dev) Title / description Author / contact info bug reporting license (include discussion of license file) versioning 5.1 5.2 "],
["code.html", "Chapter 6 Source Code 6.1 6.2 ", " Chapter 6 Source Code Discuss where to add source code and how to think about layers of modularity… 6.1 6.2 "],
["test.html", "Chapter 7 Testing 7.1 7.2 ", " Chapter 7 Testing TBD… 7.1 7.2 "],
["object-docs.html", "Chapter 8 Object Documentation 8.1 8.2 ", " Chapter 8 Object Documentation function documentation module level docs package level doc etc. 8.1 8.2 "],
["changelog.html", "Chapter 9 Changelog", " Chapter 9 Changelog Discuss the basic developer workflow for packages… "],
["readme.html", "Chapter 10 README", " Chapter 10 README TBD… "],
["website.html", "Chapter 11 Package Website", " Chapter 11 Package Website TBD… "],
["other.html", "Chapter 12 Other Components", " Chapter 12 Other Components TBD… "],
["tbd.html", "Chapter 13 TBD", " Chapter 13 TBD "]
]
