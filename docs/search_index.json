[
["index.html", "Delivering Data Science Products via Packages 1 Welcome Who should read this What you need for this book Conventions used in this book Feedback Acknowledgments", " Delivering Data Science Products via Packages 2020-05-26 1 Welcome Packages are the fundamental units of reproducible R and Python code. They include reusable components, the documentation that describes how to use them, requirements to ensure the user can apply them and tests to ensure consistent and reliable functionality. In this book you’ll learn how to turn your code into packages so that you, your teammates, and others can easily download and use. Writing a package can seem overwhelming at first. So start with the basics and improve it over time. It doesn’t matter if your first version isn’t perfect as long as the next version is better. Who should read this TBD This module makes a few assumptions of your established knowledge regarding your programming skills. Below are some important assumptions made and resources to read through if you feel inadequately prepared: Complete after rest of material is finalized. Assumptions Resource Resource You should be familiar with… You should be familiar with… You should be familiar with… You should be familiar with… What you need for this book TBD Conventions used in this book The following typographical conventions are used in this book: strong italic: indicates new terms, bold: indicates package &amp; file names, inline code: monospaced highlighted text indicates functions or other commands that could be typed literally by the user, code chunk: indicates commands or other text that could be typed literally by the user 1 + 2 ## [1] 3 We will also refer to both R and Python throughout. When discussing one or the other we will typically label with the appropriate icons: Python: R: In addition to the general text used throughout, you will notice the following code chunks: Signifies a tip or suggestion Signifies a general note Signifies a warning or caution Feedback Reader comments are greatly appreciated. To report errors or bugs please post an issue at https://github.com/misk-data-science/misk-packages/issues. Acknowledgments TBD "],
["intro.html", "2 Introduction to Packaging 2.1 Why is packaging important 2.2 When packaging might not be needed 2.3 An opinionated approach", " 2 Introduction to Packaging Often, small snippets of code grow in usefulness and importance, which creates a need to share and distribute their contents. and libraries require packaging, otherwise distributing code becomes problematic and brittle. A package bundles together code, data, documentation, and tests, and is easy to share with others. People often use the terms “package” and “library” synonymously. Although there are some semantical differences between R and Python, here is how you can think of the two terms: package: generally refers to source code that is bundled up in a way that a package manager can host. PyPI and CRAN are the two primary public package managers for Python and R. When you pip install pkg (r fontawesome::fa(“python”)) or install.packages(“pkg”) (r fontawesome::fa(“r-project”)) you are installing the pkg package from a package manager onto a computer. library: generally refers to a centralized location on an operating system where installed package source code resides and can be imported into a current session (i.e. /usr/lib/R/library). When you use pip list (r fontawesome::fa(“python”)) or installed.packages() (r fontawesome::fa(“r-project”)) you will see a list of installed packages, which we refer to as libraries. When you run sys.path (Python) or .libPaths() (R) you will get the path to the library where your installed packages are stored. 2.1 Why is packaging important Why write a package? To share with others: Bundling your code into a package makes it easy for other people to use it, because like you, they already know how to use packages. If your code is in a package, any or user can easily download it, install it and learn how to use it. To make processes reproducible: When certain code processes are repeated, rather than copy-n-pasting (error prone!) packaging helps to ensure the same procedures are executed in the same way. This leads to standardized tools for standardized conventions and can save you and others time. To track changes: Packaging helps to formulize version changes of a project. Versioning allows developers a way to communicate the type of changes made to a project (i.e. bug fixes versus feature enhancement). It also allows users to “pin” a specific version that works for their project. For example, although a current package may have a version 3.2.1, your project depends on specific functionality provided in version 2.9.7. Pinning allows you to request and use that specific version. To communicate with users: Beyond versioning, packaging helps with communication between developers and end-users. Detailed documentation helps the end-users implement the code, a change log can communcate the progression of a package over its versions, users can communicate to the developers regarding bugs they’ve found or suggested feature enhancements. To provide reliability: Packaging helps to modularize code in a way that allows for, and simplifies, testing procedures. This means as your source code grows, or as you get feedback from end-users, so should your test suite grow to help improve reliability of the code base. This results in code that is reliable and trustworthy. To deploy production work: You may have code that is never reused by others; however, the code is put into production to formalize the processesing and output of the code. Packaging your project is a great way to organize, maintain, and distribute your work into production. 2.2 When packaging might not be needed To be clear, it is not necessary to package your code to address all the bullets in the previous section; but it will definitely make them easier to achieve. However, there are times when writing a package is not necessary. For example: Exploratory analysis: The exploratory phase of a project is very interactive and contains many unknowns. You may find yourself repeating some code, which may be a good time to write and reuse small functions. However, this is not the phase to start writing a package. It’s best to wait and see what results from your exploratory analysis. If there are steps in the process (i.e. data prep, model execution) that you later determine are common steps that will often be repeated in the future then a package may result from post-exploration project review. One-off projects: Many times we perform one-off ad-hoc projects. Sometimes we may be able to abstract some steps in these projects that may be repeated but often these projects contain very unique steps that are not often repeated. You most likely will use packages in your analysis but writing a package based on a one-off project is rarely a good use of time. Small scripts: Sometimes a simple , , or Bash script can go a long way and serve your primary purpose. Small individual scripts can be easy to build, execute and orchestrate; however, if you notice this small script starting to grow in size and use then it’s time to start thinking of converting it to a package. Although the above type of work may not justify a package, it often still justifies good software engineering practices such as modularity and unit tests! 2.3 An opinionated approach It is important to understand that there are several approaches and strategies to writing packages. Even within a single language there are different ways to structure a package. Consequently, understand that this book demonstrates the best practices we have found for developing, maintaining, and distributing packages. Our goal is to provide you with a short runway to writing packages as quickly as possible while following commonly used best practices. This is a lot to learn, but don’t feel overwhelmed. Start with a minimal subset of useful features and build up over time. As you write more packages you will begin to learn the lower-level details and alternative options. Do not shy away from these details as we highly recommend that you learn them. In fact, below are some additional resources that will take you to the official R and Python packaging documentation. Realize that the details in these documents can make them challenging to read. That is ok and to be expected. Our suggestion is to get the basics down, which we cover in this book, and slowly expand your knowledge base by writing more packages. : Creating R Extensions : Python Packaging User Guide "],
["structure.html", "3 Package Structure 3.1 3.2 ", " 3 Package Structure Packages have a specific structure required to be bundable, deployable, and usable. There are a set of minimum files required for both and packages but you will often see additional files in packages. Though how these files are actually named will differ between and , the organization follows a very similar pattern. The primary files and directories you will be concerned about include: Package metadata: Every package requires important metadata about the package. This file will declare various information such as package name, description, dependencies, author(s), contact information and more. Chapter 5 will discuss the details of this file. Source code directory: This is the directory that contains all the source code for end-user functionality. Here you will organize your classes, functions, etc. into one or more .R / .py scripts. Chapter 6 will discuss requirements, approaches and best practices for organizing this directory. Test directory: Every package should always contain a testing framework. These tests should include a minimum of unit tests but can also contain integration or environment specific tests. Chapter 7 will discuss the most common test approaches for and . Documentation directory: Although not necessary, good packages often will have detailed documentation hosted as a static website. These files are generally kept in a /docs folder. Chapter 11 will discuss how to make beautiful websites for your package. License file: Specifies who can and cannot use your package. This file is related to specifications made in the metadata file and will be discussed in Chapter 5. Changelog: A changelog is a log or record of all notable changes made to a project. We will discuss the changelog in Chapter 9. README: The README is often one of the first files a user sees when going to the source code location (typically Github). A good README will provide useful instructions to get started using the package quickly and also where to go to find more detailed information. We will discuss what a good README looks like in Chapter 10. Other various config or requirement files: You will often see additional files in packages. These may be various configuration files or other package components. Many of these you will be introduced along the way through this book and others will be explicitly discussed in Chapter 12. This general structure will look like the following and the sections that follow will illustrate and describe the exact structure setup for each language. . ├── package metadata file ├── source code directory │ ├── script 1 │ ├── script 2 │ └── script n ├── test directory │ ├── script 1 │ ├── script 2 │ └── script n ├── documentation directory │ └── various doc files ├── license file ├── changelog file ├── README └── other various config files and components For the sections that follow let’s assume we are creating a package called mypkg. 3.1 Within R, the basic structure of your package will look like the following. The unique items here are: DESCRIPTION: This is the file that contains the primary package metadata. R/: The R directory is where all the source code resides. NEWS: It is common convention in many R packages to title the changelog as “NEWS”. mypkg ├── DESCRIPTION ├── R/ ├── tests/ ├── docs/ ├── LICENSE ├── NEWS └── README The rest of the files are consistent with the previous section. As you’ll see in the next chapter, additional files will be produced when we build the package but these are the primary directories and files to get going with an R package. 3.2 Within Python, the basic structure of your package will look like the following. The unique items here are: setup.py: This is the file that contains the primary package metadata. src/: The src directory is where all the source code resides. mypkg ├── setup.py ├── src/ ├── tests/ ├── docs/ ├── LICENSE ├── CHANGELOG └── README The rest of the files are consistent with the first section. As you’ll see in the next chapter, additional files often included to help configure the developer environment for a package but these are the primary directories and files to create a baseline Python package. "],
["workflow.html", "4 Development Workflow 4.1 Create the package 4.2 Setup a virtual environment 4.3 Add new functionality 4.4 Document 4.5 Version control 4.6 4.7 ", " 4 Development Workflow As data scientists, we get used to common workflows that exist in exploring and modeling data. However, the package development workflow is often unique from how we are used to working. This chapter is designed to get you started on a small package so you can experience the typical workflow. First, we’ll discuss the common steps and then we will work through them for both an and version of the package. 4.1 Create the package Once you have determined the need to create a package, the first thing we need to do is identify a package name, create the basic package structure, and connect it to a version control system (i.e. Github) of interest. 4.1.1 Naming Naming our package is important. There are certain requirements we need to adhere to but, also, the name you choose should be easy to remember and follow the respective languages idiomatic approach to naming. Moreover, the name you choose should not already exist. and have slightly different requirements regarding acceptable names. In both languages, you can only use letters and numbers; however, you can’t start the name with a number. In your name can contain a . but not a - or _ while in your name can contain all three. In both languages you can combine upper and lowercase letters in the name. However, our advice is to keep the name short, all lowercase, and with no separator when possible. Examples of good approaches to name include: numpy dplyr pandas keras Once you’ve come up with a name or two you probably want to make sure that the name is not already being used. The package managers (CRAN &amp; PyPI) do not allow duplicate names so your name must be unique. Even if you don’t intend to share your package publicly, you should avoid duplicate names if possible. Both and have tools that make this easy to do and we’ll cover them in the hands-on sections of this chapter. 4.1.2 Create Once you have a name its time to create the package. This includes determining where the package will live on your operating system and creating the bare bones framework of the package. When creating a package, the source code location (path) refers to where the source lives, not where the installed form lives. Recall in Chapter 2 that installed packages all live within a library directory. But when developing, you will keep the source code somewhere else. Where should you keep source packages? The main principle is that this location should be distinct from where installed packages live. In the absence of external considerations, a typical user should designate a directory inside their home directory for and (source) packages. This may be in directories such as ~/Desktop/Packages/ or /r/packages and /python/packages. Some of us use one directory for this, others divide source packages among a few directories. This probably reflects that we are primarily tool-builders. An academic researcher might organize their files around individual publications, whereas a data scientist might organize around data products and reports. There is no particular technical or traditional reason for one specific approach. As long as you keep a clear distinction between source and installed packages, just pick a strategy that works within your overall system for file organization, and use it consistently. Once you have a location to hold the source code, both and have tools that help to automate the creation of a basic package structure. We’ll use these tools in the hands-on sections of this chapter. 4.1.3 Version control Most package development never resides solely on one operating system nor with only one developer. So not only should we be using git for version control, we should be using a hosting platform such as GitHub, GitLab, Azure Repos, or the like. So the first thing we need to do is connect our local git repository to a remote repository so we can push, pull, and merge updates we make to the package. Once we have established our remote repository, we should set up a proper branching method for our work. We advise a Git flow branching strategy where: master branch is the “production” release branch. This is the main branch where the source code always reflects a production-ready state. develop branch is the main branch where the source code always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. supporting branches are the branches where we do the majority of our work. These are the branches where we create new fixtures, fix bugs, improve documentation. In this branching approach, we will make updates to our package in a supporting branch, then do a pull request to merge these updates into the develop branch. Once the develop branch has enough updates to warrant a new release we then merge the develop to master with a pull request. This may seem like a lot to digest. If you are unfamiliar with git and branching then we recommend these tutorials to get started: Understanding the GitHub flow A successful Git branching model In the hands-on sections of this chapter we’ll walk through setting up this git flow branching strategy. 4.2 Setup a virtual environment By default, every project on your system will use the same library directory to store and retrieve packages. At first glance, this may not seem like a big deal but it does matter when different projects require different versions of dependency packages. Consider the following scenario where you have two projects: Project A and Project B, both of which have a dependency on the same library, somepkg. The problem becomes apparent when we start requiring different versions of somepkg. Maybe Project A needs v1.0.0, while Project B requires the newer v2.0.0, for example. This is a real problem for both and since they can’t differentiate between versions in the library directory. So both v1.0.0 and v2.0.0 would reside in the same directory with the same name. Since packages are stored according to just their name, there is no differentiation between versions. Thus, both Project A and Project B would be required to use the same version, which is unacceptable in many cases. This is where virtual environments come into play. Virtual environments create an isolated environment for our project. This means that each project can have its own dependencies, regardless of what dependencies every other project has. This creates better reliability during the development process. In the hands-on sections of this chapter, we’ll setup and virtual environments. We consider it a best practice to always do your development work in virtual environments. To learn more about virtual environments we suggest starting with the following tutorials: Python Virtual Environments: A Primer renv: Project Environments for R 4.3 Add new functionality So we finally have our project set-up ready, now it’s time to start adding some functionality. When adding new functionality or fixing a bug, it’s important to approach it strategically. Rather than just adding or changing code, we should do it in a way that we know whether our code is successful or not. To accomplish this, we should use a test-driven development (TDD) approach. The general idea behind TDD is to follow this basic approach: Add a test: In TDD, each new feature or bug fix begins with writing a test. This test defines a function, improvements of a function, or a case in which a function results in a bug. Run test(s) and make sure the new test fails: Before writing any source code, run the new test to ensure that it fails. Write the code: The next step is to write some code that causes the test to pass. The new code written at this stage is not perfect and may, for example, pass the test in an inelegant way. That is acceptable because it will be improved and honed in Step 5. Run tests: If all test cases now pass, the programmer can be confident that the new code meets the test requirements, and does not break or degrade any existing features. If they do not, the new code must be adjusted until they do. Refactor code: Once the source code passes the test, you should spend time refactoring and cleaning it up. A growing code base can quickly get out of control. This step ensures you take the time to reduce tech debt. Repeat: Starting with another new test, the cycle is then repeated to push forward the functionality of the source code. This may seem like a lot of steps to remember but this process is rather quick and each step takes very small incremental steps forward. After implementing a few features in this manner it quickly becomes a natural approach to software development. If you are interested in learning more about the TDD philosophy we recommend the following books: The Pragramatic Programmer (Ch. 41) Clean Code (Ch. 9) Test Driven Development 4.4 Document Once your new functionality is successfully passing tests and has been refactored, you should make sure any necessary documentation is added or updated. This will include function specific documentation, module level documentation, any code in example notebooks or vignettes and the like. 4.5 Version control Lastly, we need to now save our work to our remote repository. This typically includes staging, commiting and pushing our changes. Depending on the stage of our work we may be ready to do a pull request into the main development branch. Okay, so this may seem like a lot of steps to keep track of. Often, this feels more convoluted on paper than when you are actually implementing so let’s start working with an example package to go through these steps. 4.6 Check package name with pip search Create package directory and structure Version control Setup/activate venv Add new functionality Document Version control 4.7 Check package name with available_packages() Create package directory and structure Version control Setup/activate venv Add new functionality Document Version control "],
["metadata.html", "5 Package Metadata 5.1 5.2 ", " 5 Package Metadata Dependencies (required vs dev) Title / description Author / contact info bug reporting license (include discussion of license file) versioning 5.1 5.2 "],
["code.html", "6 Source Code 6.1 6.2 ", " 6 Source Code Discuss where to add source code and how to think about layers of modularity… 6.1 6.2 "],
["test.html", "7 Testing 7.1 7.2 ", " 7 Testing TBD… 7.1 7.2 "],
["object-docs.html", "8 Object Documentation 8.1 8.2 ", " 8 Object Documentation function documentation module level docs package level doc etc. 8.1 8.2 "],
["changelog.html", "9 Changelog", " 9 Changelog Discuss the basic developer workflow for packages… "],
["readme.html", "10 README", " 10 README TBD… "],
["website.html", "11 Package Website", " 11 Package Website TBD… "],
["other.html", "12 Other Components", " 12 Other Components TBD… "],
["tbd.html", "13 TBD", " 13 TBD "]
]
