[
["index.html", "Delivering Data Science Products via Packages Chapter 1 Welcome", " Delivering Data Science Products via Packages 2020-05-23 Chapter 1 Welcome Packages are the fundamental units of reproducible R and Python code. They include reusable components, the documentation that describes how to use them, requirements to ensure the user can apply them and tests to ensure consistent and reliable functionality. In this book you’ll learn how to turn your code into packages so that you, your teammates, and others can easily download and use. Writing a package can seem overwhelming at first. So start with the basics and improve it over time. It doesn’t matter if your first version isn’t perfect as long as the next version is better. "],
["intro.html", "Chapter 2 Introduction 2.1 Why is packaging important 2.2 When packaging might not be needed 2.3 Assumptions 2.4 An opinionated approach", " Chapter 2 Introduction Often, small snippets of code grow in usefulness and importance, which creates a need to share and distribute their contents. R and Python libraries require packaging, otherwise distributing code becomes problematic and brittle. A package bundles together code, data, documentation, and tests, and is easy to share with others. People often use the terms “library” and “package” synonymously. Although there are some semantical differences between R and Python, here is how you can think of the two terms: library: generally refers to source code that has been installed on an operating system in a centralized location and can be imported into a current session. When you use pip list (Python) or installed.packages() (R) you will see a list of installed packages, which we refer to as libraries. When you import pkg (Python) or library(pkg) (R) you are loading the pkg library into your current session for use. package: generally refers to source code that is bundled up in a way that a package manager can host. PyPI and CRAN are the two primary public package managers for Python and R. When you pip install pkg (Python) or install.packages(“pkg”) (R) you are installing the pkg package from a package manager onto a computer. 2.1 Why is packaging important Why write a package? To share with others: Bundling your code into a package makes it easy for other people to use it, because like you, they already know how to use packages. If your code is in a package, any R or Python user can easily download it, install it and learn how to use it. To make processes reproducible: When certain code processes are repeated, rather than copy-n-pasting (error prone!) packaging helps to ensure the same procedures are executed in the same way. This leads to standardized tools for standardized conventions and can save you and others time. To track changes: Packaging helps to formulize version changes of a project. Versioning allows developers a way to communicate the type of changes made to a project (i.e. bug fixes versus feature enhancement). It also allows users to “pin” a specific version that works for their project. For example, although a current package may have a version 3.2.1, your project depends on specific functionality provided in version 2.9.7. Pinning allows you to request and use that specific version. To communicate with users: Beyond versioning, packaging helps with communication between developers and end-users. Detailed documentation helps the end-users implement the code, a change log can communcate the progression of a package over its versions, users can communicate to the developers regarding bugs they’ve found or suggested feature enhancements. To provide reliability: Packaging helps to modularize code in a way that allows for, and simplifies, testing procedures. This means as your source code grows, or as you get feedback from end-users, so should your test suite grow to help improve reliability of the code base. This results in code that is reliable and trustworthy. To deploy production work: You may have code that is never reused by others; however, the code is put into production to formalize the processesing and output of the code. Packaging your project is a great way to organize, maintain, and distribute your work into production. 2.2 When packaging might not be needed To be clear, it is not necessary to package your code to address all the bullets in the previous section; but it will definitely make them easier to achieve. However, there are times when writing a package is not necessary. For example: Exploratory analysis: The exploratory phase of a project is very interactive and contains many unknowns. You may find yourself repeating some code, which may be a good time to write and reuse small functions. However, this is not the phase to start writing a package. It’s best to wait and see what results from your exploratory analysis. If there are steps in the process (i.e. data prep, model execution) that you later determine are common steps that will often be repeated in the future then a package may result from post-exploration project review. One-off projects: Many times we perform one-off ad-hoc projects. Sometimes we may be able to abstract some steps in these projects that may be repeated but often these projects contain very unique steps that are not often repeated. You most likely will use packages in your analysis but writing a package based on a one-off project is rarely a good use of time. Small scripts: Sometimes a simple R, Python, or Bash script can go a long way and serve your primary purpose. Small individual scripts can be easy to build, execute and orchestrate; however, if you notice this small script starting to grow in size and use then it’s time to start thinking of converting it to a package. Although the above type of work may not justify a package, it often still justifies good software engineering practices such as modularity and unit tests! 2.3 Assumptions This module makes a few assumptions of your established knowledge regarding your programming skills. Below are some important assumptions made and resources to read through if you feel inadequately prepared: Assumptions Python Resource R Resource You should be familiar with… You should be familiar with… You should be familiar with… You should be familiar with… 2.4 An opinionated approach It is important to understand that there are several approaches and strategies to writing packages. Even within a single language there are different ways to structure a package. Consequently, understand that this book demonstrates the best practices we have found for developing, maintaining, and distributing packages. Our goal is to provide you with a short runway to writing packages as quickly as possible while following commonly used best practices. This is a lot to learn, but don’t feel overwhelmed. Start with a minimal subset of useful features and build up over time. As you write more packages you will begin to learn the lower-level details and alternative options. Do not shy away from these details as we highly recommend that you learn them. In fact, below are some additional resources that will take you to the official R and Python packaging documentation. Realize that the details in these documents can make them challenging to read. That is ok and to be expected. Our suggestion is to get the basics down, which we cover in this book, and slowly expand your knowledge base by writing more packages. R: Creating R Extensions Python: Python Packaging User Guide "],
["structure.html", "Chapter 3 Package Structure 3.1 R 3.2 Python", " Chapter 3 Package Structure Packages have a specific structure required to be bundable, deployable, and usable. There are a set of minimum files required for both R and Python packages but you will often see additional files in packages. . ├── package metadata file ├── source code directory │ ├── script 1 │ ├── script 2 │ └── script n ├── test directory │ ├── script 1 │ ├── script 2 │ └── script n ├── documentation directory │ └── various doc files ├── license file ├── changelog / news file ├── README └── other various config files 3.1 R 3.2 Python "],
["workflow.html", "Chapter 4 Development Workflow 4.1 R 4.2 Python", " Chapter 4 Development Workflow Discuss the basic developer workflow for packages… virtual environments TDD adding functionality documenting running tests etc. 4.1 R 4.2 Python "],
["code.html", "Chapter 5 Source Code 5.1 R 5.2 Python", " Chapter 5 Source Code Discuss where to add source code and how to think about layers of modularity… 5.1 R 5.2 Python "],
["metadata.html", "Chapter 6 Package Metadata 6.1 R 6.2 Python", " Chapter 6 Package Metadata Dependencies (required vs dev) Title / description Author / contact info bug reporting license versioning 6.1 R 6.2 Python "]
]
